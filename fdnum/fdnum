#!/usr/bin/env perl
use warnings;
use strict;
use utf8;
use Locale::Messages qw (textdomain bindtextdomain gettext nl_putenv);
binmode(STDIN, ":encoding(utf8)");
binmode(STDOUT, ":encoding(utf8)");
binmode(STDERR, ":encoding(utf8)");
binmode STDOUT, ':raw';


# return codes
our ($state_ok,$state_warn,$state_crit,$state_unkn,$state_noop) = (0,1,2,3,4);

# return stuff
our ($rc, $result) = (0,'');

our $eminfo = '/usr/local/eminfo/eminfo';
our $filename = (split /\//, __FILE__)[-1];

# check eminfo
unless (-f $eminfo && -x $eminfo) {
  printf "{unknown}:{str}:{$eminfo not prepared.}";
  exit $state_unkn;
}

# read eminfo locale_def
our $localdir = '/usr/local/eminfo/share/locale/';
open my $fh, "$eminfo printdef LOCALE_DIR 2>&- |";
if($fh){
  while(<$fh>){
  	chomp; $localdir = $_;
  	last;
  }
}

# read plugin locale setting
our $locale = 'zh_CN.UTF-8';
open $fh, "$eminfo view $filename locale 2>&- |";
if($fh){
  while(<$fh>){
        chomp; $locale = $_;
        last;
  }
  if(!defined $locale || $locale eq ''){
        open my $fh1, "$eminfo view default locale 2>&- |";
        if($fh1){
                while(<$fh1>){
                        chomp; $locale = $_;
                        last;
                }
        }
  }
}
if(!defined $locale || $locale eq ''){
        $locale = 'zh_CN.UTF-8';
}elsif($locale eq 'zh_CN' || $locale eq 'zh_CN.UTF-8' || $locale eq 'zh'){
        $locale = 'zh_CN.UTF-8';
}elsif($locale eq 'en_US' || $locale eq 'en_US.UTF-8' || $locale eq 'en'){
        $locale = 'en_US.UTF-8';
}else{
        $locale = 'zh_CN.UTF-8';
}
nl_putenv("LANGUAGE=$locale");

# set textdomain; bindtextdomain
sub _ ($) { &gettext; }
textdomain "$filename";
bindtextdomain "$filename", "$localdir";

# read plugin config here
our $max_limit = 7500;
open $fh, "$eminfo view $filename max_limit 2>&- |";
if($fh){
  while(<$fh>){
  	chomp; $max_limit = $_;
  	last;
  }
}
$max_limit = 7500 if $max_limit =~ /\D/;

# Main body begin
my $procfile = "/proc/sys/fs/file-nr";
if (-f $procfile && -r $procfile) {
  if (open my $fh, "<", $procfile) {
  	my ($fd_allocated, $fd_free, $max_fd) = (split /\s+/, <$fh>)[0,1,2];
	if ($fd_allocated > $max_limit) {
		$result = sprintf(_"allocated: %d > %d ### allocated but free: %d ### max allowed: %d ###",$fd_allocated,$max_limit,$fd_free,$max_fd);
		printf _"{warn}:{str}:{ File Descriptor Number CRITICAL | %d file descriptor allocated | %s }",$fd_allocated,$result;
  		exit $state_warn;
	} 
	$result = sprintf(_"allocated: %d <= %d ### allocated but free: %d ### max allowed: %d ###",$fd_allocated,$max_limit,$fd_free,$max_fd);
	printf _"{ok}:{str}:{ File Descriptor Number OK | %d file descriptor allocated | %s }",$fd_allocated,$result;
	exit $state_ok;
  }
  close $fh;
} else {
  printf _"{unknown}:{str}:{ File Descriptor Number UNKNOWN | proc file not prepared | %s not prepared }",$procfile;
  exit $state_unkn;  
}
