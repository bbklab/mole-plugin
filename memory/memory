#!/usr/bin/env bash



BASE_DIR="/usr/local/eminfo/"
# === LOAD GETTEXT.SH FILE
if [ -f "/usr/bin/gettext.sh"  -a -s "/usr/bin/gettext.sh" ]; then
        source "/usr/bin/gettext.sh" 2>&1
        rc=$?
        [ "$rc" != "0" ] && {
                echo -en "{unknown}:{str}:{load [/usr/bin/gettext.sh] failed with status $rc}"
                exit 3
        }   
else
        echo -en "{unknown}:{str}:{[/usr/bin/gettext.sh] not exists or empty, maybe gettext not installed. exit}"
        exit 3
fi

# === LOAD INCLUDE FILE
if [ -f "${BASE_DIR}/bin/include" -a -s "${BASE_DIR}/bin/include" ]; then
        source ${BASE_DIR}/bin/include 2>&- 
else    
        echo -en "{unknown}:{str}:{include file not exists or empty}"
        exit 3
fi

# === SET TEXTDOMAINDIR TEXTDOMAIN
if [ -d "${LOCALE_DIR}" -a -r "${LOCALE_DIR}" ]; then
        export TEXTDOMAINDIR="${LOCALE_DIR}"
        export TEXTDOMAIN="memory"
else    
        echo -en "{unknown}:{str}:{locale directory [${LOCALE_DIR}] not exist or accessable, exit}"
        exit 3
fi


# === SET GLOBAL LOCALE
glocale=$(get_locale memory)
if [ -z "${glocale}" ]; then
        export LANG="${LANG}"           ## read from sysenv
elif [ "${glocale}" == "zh_CN" -o "${glocale}" == "zh_CN.UTF-8" -o "${glocale}" == "zh" ]; then
        export LANG="zh_CN.UTF-8"
elif [ "${glocale}" == "en_US" -o "${glocale}" == "en_US.UTF-8" -o "${glocale}" == "en" ]; then
        export LANG="en_US.UTF-8"
else
        export LANG="zh_CN.UTF-8"
fi


show_help(){
cat <<EOF
Arguments:   {d|data|h|help}
Usage	 :   data
Output   :   {mem_size}M {mem_free}M {mem_used_pct}%  {swp_size}M {swp_free}M {swp_used_pct}%
Example  :   386M 313M 19.100%  799M 792M 1.000%
EOF
exit 0;
}
MODE=0
[ "$1" == "data" -o "$1" == "d" ] && MODE=1
[ "$1" == "help" -o "$1" == "h" ] && show_help;


# Return Codes
STATE_OK=0
STATE_WARNING=1
STATE_CRITICAL=2
STATE_UNKNOWN=3
STATE_NOOP=4

# Set Default
EXIT_STATUS=0
LEVEL=    	### { ok | warn | crit | unknown | noop }
TYPE=    	### { str| file }
CONTENT=        ### { strings | /path/to/result.file }

# Read plugin config value here
mem_uplimit=$(read_eminfo_config memory mem_uplimit)
swp_uplimit=$(read_eminfo_config memory swp_uplimit)

# if null return STATE_UNKNOWN.

# if null or invalid set default.
[ -z "${mem_uplimit}" -o ! -z "${mem_uplimit//[0-9.]}" ] && mem_uplimit=99.99
[ -z "${swp_uplimit}" -o ! -z "${swp_uplimit//[0-9.]}" ] && swp_uplimit=10

# check function here
check(){

  [ -f "/proc/meminfo" -a -r "/proc/meminfo" ] || {
	EXIT_STATUS=${STATE_UNKNOWN};
	LEVEL="unknown";
	TYPE="str";
	CONTENT="$(gettext "File: [/proc/meminfo] not prepared.")";
	return
  }

  # collect data
  local mem_total=$(awk '/^MemTotal:/ {print $2;exit;}' /proc/meminfo 2>&-)
  local mem_free=$(awk '/^MemFree:/ {print $2;exit;}' /proc/meminfo 2>&-)
  local swp_total=$(awk '/^SwapTotal:/ {print $2;exit;}' /proc/meminfo 2>&-)
  local swp_free=$(awk '/^SwapFree:/ {print $2;exit;}' /proc/meminfo 2>&-)
  local mem_percent=$( echo "scale=3; 100 * (1 - ${mem_free}/${mem_total})" | bc 2>&- )
  local swp_percent=$( echo "scale=3; 100 * (1 - ${swp_free}/${swp_total})" | bc 2>&- )

  # output plugin format data if MODE=0
  [ -z "${mem_total}" -o ! -z "${mem_total//[0-9]}" -o -z "${mem_free}" -o ! -z "${mem_free//[0-9]}" ] && {
	EXIT_STATUS=${STATE_UNKNOWN};
	LEVEL="unknown";
	TYPE="str";
	CONTENT="$(eval_gettext "memory total=[\${total}] or memory free=[\${free}] is not numberic.")";
	return
  }

  [ -z "${swp_total}" -o ! -z "${swp_total//[0-9]}" -o -z "${swp_free}" -o ! -z "${swp_free//[0-9]}" ] && {
	EXIT_STATUS=${STATE_UNKNOWN};
	LEVEL="unknown";
	TYPE="str";
	CONTENT="$(eval_gettext "swap total=[\${total}] or swap free=[\${free}] is not numberic.")";
	return
  }

  [ -z "${mem_percent}" -o ! -z "${mem_percent//[0-9.]}" -o -z "${swp_percent}" -o ! -z "${swp_percent//[0-9.]}" ] && {
	EXIT_STATUS=${STATE_UNKNOWN};
        LEVEL="unknown";
        TYPE="str";
        CONTENT="$(eval_gettext "Retuen is not numberic: [\${mem_percent}] or [\${swp_percent}]")";
	return 
  }

  # output data and exit if MODE=1
  [ "${MODE}" == "1" ] && {
	echo "$((${mem_total}/1024))M $((${mem_free}/1024))M ${mem_percent}% "\
		"$((${swp_total}/1024))M $((${swp_free}/1024))M ${swp_percent}%"
	exit
  }

  oknum=0 warnnum=0 total=0 result=
  mem_total=$((${mem_total}/1024))  mem_free=$((${mem_free}/1024))
  mem_detail="$(eval_gettext "total=\${mem_total}M  free=\${mem_free}M")"
  if [ "$(echo  "${mem_percent} >= ${mem_uplimit}" | bc 2>&-)" == "1" ]; then
	((warnnum++))
	result="${result} ### $(html_yellow "$(eval_gettext "Memory Usage: [\${mem_percent}]% >= Uplimit: [\${mem_uplimit}%]")") ### ${mem_detail} ###"
  else
	((oknum++))
	result="${result} ### $(eval_gettext "Memory Usage: [\${mem_percent}]% <= Uplimit: [\${mem_uplimit}%]") ### ${mem_detail} ###"
  fi

  swp_total=$((${swp_total}/1024)) swp_free=$((${swp_free}/1024))
  swp_detail="$(eval_gettext "total=\${swp_total}M  free=\${swp_free}M")"
  if [ "$(echo  "${swp_percent} >= ${swp_uplimit}" | bc 2>&-)" == "1" ]; then
	((warnnum++))
	result="${result} ### $(html_yellow "$(eval_gettext "Swap Usage: [\${swp_percent}]% >= Uplimit: [\${swp_uplimit}%]")") ### ${swp_detail} ###"
  else
	((oknum++))
	result="${result} ### $(eval_gettext "Swap Usage: [\${swp_percent}]% <= Uplimit: [\${swp_uplimit}%]") ### ${swp_detail} ###"
  fi

  total=$((${warnnum}+${oknum}))
  if [ ${warnnum} -gt 0 ]; then
	local rsz_top_ps=$(ps -eo pid,comm,rsz|tail -n +2|sort -rn -k 3|head|sed -e 's/$/###/g' | tr -d '\n')
	local vsz_top_ps=$(ps -eo pid,comm,vsz|tail -n +2|sort -rn -k 3|head|sed -e 's/$/###/g' | tr -d '\n')
	EXIT_STATUS=${STATE_WARNING};
	LEVEL="warn";
	TYPE="str";
	CONTENT="$(gettext "Memory/Swap Usage Check WARNING") | $(eval_gettext "\${warnnum}/\${total} check failed.") | ${result} ### $(gettext "RSZ_TOP:") ### ${rsz_top_ps} ### ###  $(gettext "VSZ_TOP:") ### ${vsz_top_ps}"
	((oknum++))
  else
	EXIT_STATUS=${STATE_OK};
	LEVEL="ok";
	TYPE="str";
	CONTENT="$(gettext "Memory/Swap Usage Check OK") | $(eval_gettext "\${oknum}/\${total} check success.") | ${result}"
  fi
}

check

# output result and return exit status here.
echo "{"${LEVEL}"}:{"${TYPE}"}:{"${CONTENT}"}"  | tr -d '\015\012'
exit ${EXIT_STATUS}
