#!/usr/bin/env perl
use warnings;
use strict;
use utf8;
use JSON;
# use Smart::Comments;
binmode(STDIN, ":encoding(utf8)");
binmode(STDOUT, ":encoding(utf8)");

$| = 1;

# return codes
our ($state_ok,$state_warn,$state_crit,$state_unkn,$state_noop,$state_notify) = (0,1,2,3,4,5);

# return stuff
our ($rc, $result) = (0,'');

our $filename = (split /\//, __FILE__)[-1];

#
#  BEGIN to COLLECT SYSTEM INFORMATION 
#

my %product_info = (
  'manufacturer'		=> '',
  'productname'			=> '',
  'productuuid'			=> '',
  'serialnumber'		=> '',
  'biosvendor'			=> '',
  'biosversion'			=> '',
  'biosreleasedate'		=> '',
  'baseboardmanufacturer'	=> '',
  'baseboardproductname'	=> '',
  'baseboardversion'		=> '',
  'baseboardserialnumber'	=> '',
);
my %mem_info = (
  'memmaxcapacity'	=> '',		# Memory Maximum Capacity
  'memmaxdevnum'	=> '',		# Memory Maxinum Plugin Interface
  'memfreedevnum'	=> '',		# Memory Free Plugin Interface
  'meminstallednum'	=> '',		# Memory Installed Number
  'meminstalledsize'	=> '',		# Memory Installed Size (by each)
  'memtype'		=> '',
  'memspeed'		=> '',
  'os_mem_total'	=> '',
  'os_swap_total'	=> '',
);
my $dmidecode = '/usr/sbin/dmidecode';	# dmidecode >= 2.7, [OS >= rhel 5.1]
if (-f $dmidecode && -x $dmidecode) {
  %product_info = (
  	'manufacturer'		=> 'system-manufacturer',
  	'productname'		=> 'system-product-name',
  	'productuuid'		=> 'system-uuid',
  	'serialnumber'		=> 'system-serial-number',
  	'biosvendor'		=> 'bios-vendor',
  	'biosversion'		=> 'bios-version',
  	'biosreleasedate'	=> 'bios-release-date',
	'baseboardmanufacturer'	=> 'baseboard-manufacturer',
	'baseboardproductname'	=> 'baseboard-product-name',
	'baseboardversion'	=> 'baseboard-version',
	'baseboardserialnumber' => 'baseboard-serial-number',
  );
  foreach my $key (keys %product_info) {
    open my $fh, "$dmidecode -s $product_info{$key} 2>&1 |";
    if ($fh) {
	while (<$fh>) {
		chomp; s/(\A\s+|\s+\Z)//g;
		next if m/\A\s*#/;
		s/\A\s*//; s/\s*\Z//g; $product_info{$key} = $_;
		last;
	}
    }
  }

  open my $fh, "$dmidecode -t memory 2>&1 |";
  if ($fh) {
	my $memdev_start = 0;
	my @meminstalledsize = ();
	my (%memtype,%memspeed);
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if (m/\A\s*\Z/){
			$memdev_start = 0;
			next;
		}
		if (m/\A\s*Maximum\s+Capacity:/i) {
			$mem_info{'memmaxcapacity'} = (split /:\s+/)[1];
			next;
		}
		if (m/\A\s*Memory Device/i) {
			$memdev_start = 1;
			$mem_info{'memmaxdevnum'}++;
			next;
		}
		if (m/\A\s*Size:/i) {
			(my $size = (split /:/)[1]) =~ s/\A\s*//g;
			if ($size =~ /\d+ MB/i) {
				$mem_info{'meminstallednum'}++;
				push @meminstalledsize, $size;
			}
			next;
		}
		if (m/\A\s*Type:/i && $memdev_start == 1) {
			(my $memtype = (split /:/)[1]) =~ s/\A\s*//g;
			$memtype{$memtype}++;
			next;
		}
		if (m/\A\s*Speed:/i && $memdev_start == 1) {
			(my $memspeed = (split /:/)[1] ) =~ s/\A\s*//g;
			$memspeed{$memspeed}++;
			next;
		}
	}
        if ($mem_info{'memmaxdevnum'} ne '' && $mem_info{'meminstallednum'} ne ''){
                $mem_info{'memfreedevnum'} = $mem_info{'memmaxdevnum'} - $mem_info{'meminstallednum'};
        }
	$mem_info{'meminstalledsize'} = \@meminstalledsize;
	$mem_info{'memtype'} = \%memtype;
	$mem_info{'memspeed'} = \%memspeed;
  }
}
my $mem_file = '/proc/meminfo';
if (-f $mem_file && -r $mem_file) {
  if(open my $fh, "<", $mem_file){
  	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if (m/\AMemTotal:/i) {
			$mem_info{'os_mem_total'} = int((split /\s+/)[1]/1024).' MB';
			next;
		}
		if (m/\ASwapTotal:/i) {
			$mem_info{'os_swap_total'} = int((split /\s+/)[1]/1024).' MB';
			next;
		}
  	}
  close $fh;
  }
}
### %product_info
### %mem_info



my %cpu_info = (
  'vendor'	=> '',
  'type'	=> '',
  'physical'	=> '',
  'logical'	=> '',
  'speed'	=> '',
);
my $cpu_file = '/proc/cpuinfo';
if (-f $cpu_file && -r $cpu_file) {
  if (open my $fh, "<", $cpu_file) {
	my (%cpu_phyid, %cpu_speed, %cpu_vendor, %cpu_type);
        while(<$fh>){
                chomp; s/(\A\s+|\s+\Z)//g;
		if (m/\Aprocessor\s+/i) {
			$cpu_info{'logical'}++;
			next;
		}
		if (m/\Aphysical\s+id\s+/i) {
			$cpu_phyid{$_}++;
			next;
		}
		if (m/\Acpu\s+MHz\s+/i) {
			(my $speed = (split /:/)[1]) =~ s/\A\s*//g;
			$cpu_speed{$speed.'MHz'}++;
			next;
		}
		if (m/\Avendor_id\s+/i) {
			(my $vendor = (split /:/)[1]) =~ s/\A\s*//g;
			$cpu_vendor{$vendor}++;
			next;
		}
		if (m/\Amodel\s+name\s+/i) {
			(my $type = (split /:/)[1]) =~ s/\A\s*//g;
			$cpu_type{$type}++;
			next;
		}
        }
	$cpu_info{'physical'} = scalar keys %cpu_phyid;
	$cpu_info{'physical'} = 1 if $cpu_info{'physical'} == 0;
	$cpu_info{'speed'} = \%cpu_speed;
	$cpu_info{'vendor'} = \%cpu_vendor;
	$cpu_info{'type'} = \%cpu_type;
  }
}
### %cpu_info




 
my @input_dev = ();
my $input_devfile = '/proc/bus/input/devices';
if (-f $input_devfile && -r $input_devfile) {
  open my $fh, "<", $input_devfile;
  if ($fh) {
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if (m/\AN: /i) {
			s/[\"\']//g;
			push @input_dev, (split/=/)[1];
		}
	}
  }
}
### @input_dev


my %os_info = (
  'os_distribute'	=> '',
  'os_release'		=> '',
  'os_manufacturer'	=> '',
  'os_codename'		=> '',
  'os_descript'		=> '',
  'os_bitmode'		=> '',
  'arch'		=> '',
  'os'			=> '',
  'kernel_name'		=> '',
  'kernel_release' 	=> '',
  'hostname'		=> '',
);
my $lsb_release = "/usr/bin/lsb_release";
if (-f $lsb_release && -x $lsb_release) {
  open my $fh, "$lsb_release -a 2>&1 |";
  if ($fh) {
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		next if m/\ALSB Version/i;
		my ($key,$value) = split /:/;
		$key = 'os_distribute' if $key =~ /\ADistributor ID/i;
		$key = 'os_release' if $key =~ /\ARelease/i;
		$key = 'os_codename' if $key =~ /\ACodename/i;
		$key = 'os_descript' if $key =~ /\ADescription/i;
		$value =~ s/\A\s*//g;
		$os_info{$key} = $value;
	}
	if ($os_info{'os_distribute'} =~ m/centos/i) {
		$os_info{'os_manufacturer'} = 'centos';
	} elsif ($os_info{'os_distribute'} =~ m/redhat/i) {
		$os_info{'os_manufacturer'} = 'redhat';
	} elsif ($os_info{'os_distribute'} =~ m/fedora/i) {
		$os_info{'os_manufacturer'} = 'fedora';
	} elsif ($os_info{'os_distribute'} =~ m/suse/i) {
		$os_info{'os_manufacturer'} = 'suse';
	}
  }
}
my $getconf = "/usr/bin/getconf";
if (-f $getconf && -x $getconf) {
  open my $fh, "$getconf LONG_BIT 2>&1 |";
  if ($fh) {
	while(<$fh>){
		chomp; s/\A\s*//; s/\s*\Z//g; $os_info{'os_bitmode'} = $_;
	}
  }
}
my $uname = "/bin/uname";
if (-f $uname && -x $uname) {
  my %uname_info = (
  	'arch'			=> '-m',
  	'os'			=> '-o',
  	'kernel_name'		=> '-s',
  	'kernel_release' 	=> '-r',
  	'hostname'		=> '-n',
  );
 foreach my $key (keys %uname_info){
   open my $fh, "$uname $uname_info{$key} 2>&1 |";
   if ($fh) {
	while(<$fh>){
		chomp; s/\A\s*//; s/\s*\Z//g; $os_info{$key} = $_;
		last;
	}
   }
 }
}
### %os_info



my %sys_clock = (
  'timezone'		=> '',
  'useutc'		=> '',
);
my $clockfile = '/etc/sysconfig/clock';
if (-f $clockfile && -r $clockfile) {
  if(open my $fh, "<", $clockfile){
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if (m/\AZONE=/) {
			s/"//g;
			$sys_clock{'timezone'} = (split/=/)[1];
			next;
		}
		if (m/\AUTC=/) {
			$sys_clock{'useutc'} = (split/=/)[1];
			next;
		}
	}
	close $fh;
  }
}
### %sys_clock


my %sys_lang = (
  'lang_default'	=> '',
  'lang_supported'	=> '',
  'font_default'	=> '',
);
my $i18nfile = '/etc/sysconfig/i18n';
if (-f $i18nfile && -r $i18nfile) {
  if(open my $fh, "<", $i18nfile){
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if (m/\ALANG=/){
			s/"//g;
			$sys_lang{'lang_default'} = (split/=/)[1];
			next;
		}
		if (m/\ASUPPORTED=/){
			s/"//g;
			$sys_lang{'lang_supported'} = (split/=/)[1];
			next;
		}
		if (m/\ASYSFONT=/){
			s/"//g;
			$sys_lang{'font_default'} = (split/=/)[1];
			next;
		}
	}
	close $fh;
  }
}
### %sys_lang



my %selinux = (
  'status'		=> '',
  'type'		=> '',
);
my $selinuxfile = '/etc/selinux/config';
if (-f $selinuxfile && -r $selinuxfile) {
  if (open my $fh, "<", $selinuxfile) {
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		next if /\A\s*#/;
		if (m/\A\s*SELINUX\b/) {
			$selinux{'status'} = (split/=/)[1];
			next;
		}
		if (m/\A\s*SELINUXTYPE\b/) {
			$selinux{'type'} = (split/=/)[1];
			next;
		}
	}
	close $fh;
  }
}
### %selinux


my @sysuser = ();
my $userfile = '/etc/passwd';
if (-f $userfile && -r $userfile) {
  if(open my $fh, "<", $userfile){
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		my ($name,$uid,$gid,$homedir,$shell) = (split /:/)[0,2,3,5,6];
		if (defined $shell && -e $shell && $shell =~ /sh\Z/) {
			my %sysuser = (
  				'name'		=> $name,
  				'uid'		=> $uid,
  				'gid'		=> $gid,
  				'homedir'	=> (-d $homedir) ? $homedir : "$homedir (Missing)",
  				'shell'		=> $shell,
			);
			push @sysuser, \%sysuser;
		}
	}
	close $fh;
  }
}
### @sysuser


my $runlevel = 'X';
my $inittab = '/etc/inittab';
if (-f $inittab && -r $inittab) {
  if(open my $fh, "<", $inittab){
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if (m/\A\s*id:/){
			$runlevel = (split /:/)[1];
			last;
		}
	}
	close $fh;
  }
}
### $runlevel


my @startups = ();
my $startdir = "/etc/rc$runlevel.d/";
if (-d $startdir && -r $startdir) {
  my @start_files = (glob "$startdir/S*");
  foreach(@start_files){
	my $start_file = (split /\//)[-1];
	if(defined $start_file){
		$start_file =~ s/\AS\d+//;
		$start_file = 'rc.local' if $start_file eq 'local';
		push @startups, $start_file;
	}
  }
}
### @startups




my @dns = ();
my $dnsfile = '/etc/resolv.conf';
if (-f $dnsfile && -r $dnsfile) {
  if(open my $fh, "<", $dnsfile){
	while(<$fh>){
		if(m/\A\s*nameserver\s+(.+)\s*\Z/){
			push @dns, $1;
		}
	}
	close $fh;
  }
}
### @dns



my @route = ();
my $route = '/sbin/route';
if (-f $route && -x $route) {
   open my $fh, "$route -n 2>&- |"; 
   if ($fh) {
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if(m/\A\s*\d/i){
			my %route_way;
			@route_way{'dest','gateway','genmask','flag','metric','ref','use','iface'} = split /\s+/;
			push @route, \%route_way;
		}
	}
	close $fh;
   }
}
### @route


my @arp = ();
my $arpfile = '/proc/net/arp';
if (-f $arpfile && -r $arpfile) {
   if (open my $fh, "<", $arpfile) {
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if(m/\A\s*\d/i){
			my %arp_addr;
			@arp_addr{'ip','mac'} = (split /\s+/)[0,3];
			push @arp, \%arp_addr;
		}
	}
	close $fh if $fh;
   }
}
### @arp



my @mount = ();
my $mtabfile = '/etc/mtab';
if (-f $mtabfile && -r $mtabfile) {
  if (open my $fh, "<", $mtabfile) {
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		my %mount_dev;
		@mount_dev{'dev','mount','fstype','args'} = (split /\s+/)[0,1,2,3];
		if ($mount_dev{'fstype'} =~ m/\b(ext2|ext3|ext4|nfs|gfs|gfs2)\b/i) {
			push @mount, \%mount_dev;
		}
	}
	close $fh if $fh;
  }
}
### @mount


# only for inner called
my %netcard;
my $lspci = '/sbin/lspci';
if (-f $lspci && -x $lspci) {
  open my $fh, "$lspci 2>&- |";
  if ($fh) {
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if (m/Ethernet controller:/i) {
			my $busid = (split /\s+/)[0];
			my $desc = (split /Ethernet controller:\s+/i)[1];
			$netcard{$busid} = $desc;
		}
	}
  }
}

my @inet_name = ();
my $netfile = '/proc/net/dev';
my $ethtool = '/sbin/ethtool';
my $ifconfig = '/sbin/ifconfig';
if (-f $netfile && -r $netfile) {
  my @netfaces = ();
  if(open FH1, "<", $netfile){
	while(<FH1>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if(/\A\s*(\w+?):\s*(\d+)/i){
			next if ($1 eq 'lo' || $1 eq 'sit0' || $1 =~ m/range/i);
			push @netfaces, $1;
		}
	}
	close FH1;
  }
  foreach(@netfaces){
	chomp; s/(\A\s+|\s+\Z)//g;
	my $inet_name = $_;
	my %inet_info = (
		'name'			=> $inet_name,
		'speed'			=> '',
		'duplex'		=> '',
		'is_autoneg'		=> '',
		'is_linked'		=> '',
		'driver'		=> '',
		'driver_version'	=> '',
		'firmware_version'	=> '',
		'pci_busid'		=> '',
		'pci_description'	=> '',
		'encapsulation'		=> '',
		'mac_address'		=> '',
		'ipv4_address'		=> '',
		'ipv4_netmask'		=> '',
		'mtu'			=> '',
		'promisc_mode'		=> 'off',
	);
	if (-f $ethtool && -x $ethtool) {
		open my $fh, "$ethtool $inet_name 2>&1 | ";
		if ($fh) {
			while(<$fh>){
				chomp; s/(\A\s+|\s+\Z)//g;
				$inet_info{'speed'} = (split/:\s+/)[1] if m/\A\s*Speed:/;
				$inet_info{'duplex'} = (split/:\s+/)[1] if m/\A\s*Duplex:/;
				$inet_info{'is_autoneg'} = (split/:\s+/)[1] if m/\A\s*Auto-negotiation:/;
				$inet_info{'is_linked'} = (split/:\s+/)[1] if m/\A\s*Link detected:/;
			}
		}
		open my $fh1, "$ethtool -i $inet_name 2>&1 | ";
		if ($fh1) {
			while(<$fh1>){
				chomp; s/(\A\s+|\s+\Z)//g;
				$inet_info{'driver'} = (split/:\s+/)[1] if m/\A\s*driver:/;
				$inet_info{'driver_version'} = (split/:\s+/)[1] if m/\A\s*version:/;
				$inet_info{'firmware_version'} = (split/:\s+/)[1] if m/\A\s*firmware-version:/;
				$inet_info{'firmware_version'} = '' if not defined($inet_info{'firmware_version'});
				$inet_info{'pci_busid'} = (split/:\s+/)[1] if m/\A\s*bus-info:/;
			}
			if (not defined ($inet_info{'pci_busid'})) {
				$inet_info{'pci_busid'} = '';
			} else {
				$inet_info{'pci_busid'} =~ s/\A(.+?)://;	# trim first xxxx:
				if (exists $netcard{$inet_info{'pci_busid'}}) {
					$inet_info{'pci_description'} = $netcard{$inet_info{'pci_busid'}};
				}
			}
		}
	}
	if (-f $ifconfig && -x $ifconfig) {
		open my $fh, "$ifconfig $inet_name 2>&1 | ";
		if ($fh) {
			while(<$fh>){
				chomp; s/(\A\s+|\s+\Z)//g;
				if(m/^$inet_name\s+Link encap:(\w+)\s+HWaddr ((?:[A-Fa-f0-9]{2}:){5}(?:[A-Fa-f0-9]{2}))\s*\Z/i){
					$inet_info{'encapsulation'} = $1;			
					$inet_info{'mac_address'} = $2;
					next;
				}
				if(m/\s*inet addr:((([0-9]|([1-9]\d)|(1\d\d)|(2([0-4]\d|5[0-5])))\.){3}([1-9]|([1-9]\d)|(1\d\d)|(2([0-4]\d|5[0-5]))))\s+(.*)Mask:(.+)\Z/){
					$inet_info{'ipv4_address'} = $1;
					$inet_info{'ipv4_netmask'} = $14;
					next;
				}
				if(m/\s+MTU:(\d+)\s+/i){
					$inet_info{'mtu'} = $1;
					next;
				}
			}
		}
	}
	my $flagfile = "/sys/class/net/$inet_name/flags";
	if (-f $flagfile && -r $flagfile) {
		open my $fh, "<", $flagfile;
		if ($fh) {
			chomp( my $int_flags = <$fh>);
			if(hex $int_flags & 0x100) {
				$inet_info{'promisc_mode'} = 'on';
			}
		}
	}
	push @inet_name, \%inet_info;
  }
}
### @inet_name


my @raid_info = ();
my $megacli = '/opt/MegaRAID/MegaCli/MegaCli64';
$megacli = '/opt/MegaRAID/MegaCli/MegaCli' if ($os_info{'os_bitmode'} eq '32');
if (-f $megacli && -x $megacli) {
  my ($i,$raid_num) = (0,0);
  open my $fh, "$megacli -adpCount -NoLog 2>&- | ";
  if($fh){
	while(<$fh>){
		chomp; s/(\A\s+|\s+\Z)//g;
		if (/\A\s*Controller Count:\s*(\d+)/i){
			$raid_num = $1;
			last;
		}
	}
  }
  for($i=0;$i<$raid_num;$i++){
  	my %raid_single = (
		'RAID_ID'			=> $i,
  		'Product_Name'			=> '',
  		'Serial_Number'			=> '',
		'BIOS_Version'			=> '',
		'RAID_BBU'			=> '',
		'RAID_Memory'			=> '',
		'RAID_Temp_Sensor'		=> '',
		'Current_Time'			=> '',
		'RAID_Supported'		=> '',
		'Supported_Drives'		=> '',
		'Virtual_Disk_Number'		=> '',
		'Virtual_Disk_Info'		=> '',
		'Physical_Disk_Number'		=> '',
		'Physical_Disks_Critical'	=> '',
		'Physical_Disks_Failed'		=> '',
		'Physical_Disk_Info'		=> '',
		'Memory_Correctable_Errors'	=> '',
		'Memory_Uncorrectable_Errors'	=> '',
		'Default_Strip_Size'		=> '',
		'Default_Write_Policy'		=> '',
		'Default_Read_Policy'		=> '',
		'Default_Cache_When_BBU_Bad'	=> '',
  	);
	my %raid_temp_sensor = (	### init  %raid_temp_sensor
		'Present'	=> 0,
		'Temperature'	=> '',
	);
	open my $fh1, "$megacli -AdpAllInfo -a$i -NoLog 2>&- | ";
	if($fh1){
		while(<$fh1>){
			chomp; s/(\A\s+|\s+\Z)//g;
			if(/\A\s*Product Name\s*:\s*(.+)\s*\Z/i){
				$raid_single{'Product_Name'} = $1;
				next;
			}
			if(/\A\s*Serial No\s*:\s*(.+)\s*\Z/i){
				$raid_single{'Serial_Number'} = $1;
				next;
			}
			if(/\A\s*BIOS Version\s*:\s*(.+)\s*\Z/i){
				$raid_single{'BIOS_Version'} = $1;
				next;
			}
			if(/\A\s*BBU\s*:\s*Present\s*\Z/i){
				my %bbu_single = (
					'Present'			=> 1,
					'Voltage'			=> '',
					'Temperature'			=> '',
					'Charging_Status'		=> '',   # Charing, Discharing, None
					'Learn_Cycle_Status'		=> '',
					'Learn_Cycle_Active'		=> '',	 # Yes, No
					'Relative_State_of_Charge' 	=> '',
					'Battery_Replacement_Required'	=> '',   # Yes, No
					'Remaining_Capacity_Low'	=> '',   # Yes, No
					'Charger_Status'		=> '',
					'Auto_Learn_Mode'		=> '',
					'Auto_Learn_Period'		=> '',
					'Next_Learn_time'		=> '',
				);
				open my $fh2, "$megacli -AdpBbuCmd -a$i -NoLog 2>&- | ";
				if($fh2){
					while(<$fh2>){
						chomp; s/(\A\s+|\s+\Z)//g;
						if(/\A\s*Voltage:\s*(.+)\s*\Z/i){
							$bbu_single{'Voltage'} = $1;
							next;
						}
						if(/\A\s*Temperature:\s*(.+)\s*\Z/i){
							$bbu_single{'Temperature'} = $1;
							next;
						}
						if(/\A\s*Charging Status\s*:\s*(.+)\s*\Z/i){
							$bbu_single{'Charging_Status'} = $1;
							next;
						}
						if(/\A\s*Learn Cycle Status\s*:\s*(.+)\s*\Z/i){
							$bbu_single{'Learn_Cycle_Status'} = $1;
							next;
						}
						if(/\A\s*Learn Cycle Active\s*:\s*(.+)\s*\Z/i){
							$bbu_single{'Learn_Cycle_Active'} = $1;
							next;
						}
						if(/\A\s*Relative State of Charge:\s*(.+)\s*\Z/i){
							$bbu_single{'Relative_State_of_Charge'} = $1;
							next;
						}
						if(/\A\s*Battery Replacement required\s*:\s*(.+)\s*\Z/i){
							$bbu_single{'Battery_Replacement_Required'} = $1;
							next;
						}
						if(/\A\s*Remaining Capacity Low\s*:\s*(.+)\s*\Z/i){
							$bbu_single{'Remaining_Capacity_Low'} = $1;
							next;
						}
						if(/\A\s*Charger Status:\s*(.+)\s*\Z/i){
							$bbu_single{'Charger_Status'} = $1;
							next;
						}
						if(/\A\s*Auto-Learn Mode:\s*(.+)\s*\Z/i){
							$bbu_single{'Auto_Learn_Mode'} = $1;
							next;
						}
						if(/\A\s*Auto Learn Period:\s*(.+)\s*\Z/i){
							$bbu_single{'Auto_Learn_Period'} = $1;
							next;
						}
						if(/\A\s*Next Learn time:\s*(.+)\s*\Z/i){
							$bbu_single{'Next_Learn_time'} = $1;
							next;
						}
					}
				}
				$raid_single{'RAID_BBU'} = \%bbu_single;
				next;
			}
			if(/\A\s*Memory Size\s*:\s*(.+)\s*\Z/i){
				$raid_single{'RAID_Memory'} = $1;
				next;
			}
			if(/\A\s*Temperature sensor for controller\s*:\s*Present\s*\Z/i){
				$raid_temp_sensor{'Present'} = 1;
				next;
			}
			if(/\A\s*Controller temperature\s*:\s*(.+)\s*\Z/i){
				$raid_temp_sensor{'Temperature'} = $1;
				next;
			}
			if(/\A\s*Current Time\s*:\s*(.+)\s*\Z/i){
				$raid_single{'Current_Time'} = $1;
				next;
			}
			if(/\A\s*RAID Level Supported\s*:\s*(.+)\s*\Z/i){
				my @raid_supported = split(/,\s+/,$1);
				$raid_single{'RAID_Supported'} = \@raid_supported;
				next;
			}
			if(/\A\s*Supported Drives\s*:\s*(.+)\s*\Z/i){
				my @drive_supported = split(/,\s+/,$1);
				$raid_single{'Supported_Drives'} = \@drive_supported;
				next;
			}
			if(/\A\s*Virtual Drives\s*:\s*(\d+)\s*\Z/i){
				$raid_single{'Virtual_Disk_Number'} = $1;
				if ($raid_single{'Virtual_Disk_Number'} > 0) {
					my @vd_array = ();
					for(my $v=0;$v<$raid_single{'Virtual_Disk_Number'};$v++){
						my %vd_single = (
							'vd_id'			=> 0,
							'raid_level'		=> '',
							'size'			=> '',
							'state'			=> '',
							'stripe_size'		=> '',
							'pdnum'			=> '',
							'depth'			=> '',
							'encryption'		=> '',
							'default_cache_policy'	=> '',
							'current_cache_policy'	=> '',
							'default_access_policy'	=> '',
							'current_access_policy'	=> '',
						);
						open my $fh3, "$megacli -LDInfo -L$v -a$i -NoLog 2>&- | ";
						if($fh3){
							while(<$fh3>){
								chomp; s/(\A\s+|\s+\Z)//g;
								if(/\A\s*Virtual Drive\s*:\s*(\d+)\s*/i){
									$vd_single{'vd_id'} = $1;
									next;
								}
								if(/\A\s*RAID Level\s*:\s*(.+)\s*\Z/i){
									$vd_single{'raid_level'} = $1;
									next;
								}	
								if(/\A\s*Size\s*:\s*(.+)\s*\Z/i){
									$vd_single{'size'} = $1;
									next;
								}	
								if(/\A\s*State\s*:\s*(.+)\s*\Z/i){
									$vd_single{'state'} = $1;
									next;
								}	
								if(/\A\s*Strip Size\s*:\s*(.+)\s*\Z/i){
									$vd_single{'stripe_size'} = $1;
									next;
								}	
								if(/\A\s*Number Of Drives\s*:\s*(\d+)\s*\Z/i){
									$vd_single{'pdnum'} = $1;
									next;
								}	
								if(/\A\s*Span Depth\s*:\s*(\d+)\s*\Z/i){
									$vd_single{'depth'} = $1;
									next;
								}	
								if(/\A\s*Encryption Type\s*:\s*(.+)\s*\Z/i){
									$vd_single{'encryption'} = $1;
									next;
								}	
								if(/\A\s*Default Cache Policy\s*:\s*(.+)\s*\Z/i){
									$vd_single{'default_cache_policy'} = $1;
									next;
								}	
								if(/\A\s*Current Cache Policy\s*:\s*(.+)\s*\Z/i){
									$vd_single{'current_cache_policy'} = $1;
									next;
								}	
								if(/\A\s*Default Access Policy\s*:\s*(.+)\s*\Z/i){
									$vd_single{'default_access_policy'} = $1;
									next;
								}	
								if(/\A\s*Current Access Policy\s*:\s*(.+)\s*\Z/i){
									$vd_single{'current_access_policy'} = $1;
									next;
								}	
							}
						}
						if ($vd_single{'raid_level'} =~ m/Primary-1, Secondary-0/i) {
							$vd_single{'raid_level'} = 'raid1';
						} elsif ($vd_single{'raid_level'} =~ m/Primary-0, Secondary-0/i) {
							$vd_single{'raid_level'} = 'raid0';
						} elsif ($vd_single{'raid_level'} =~ m/Primary-5, Secondary-0/i) {
							$vd_single{'raid_level'} = 'raid5';
						} elsif ($vd_single{'raid_level'} =~ m/Primary-1, Secondary-3/i) {
							$vd_single{'raid_level'} = 'raid10';
						}
						push @vd_array, \%vd_single;
					}
					$raid_single{'Virtual_Disk_Info'} = \@vd_array;
				}
				next;
			}
			if(/\A\s*Disks\s*:\s*(\d+)\s*\Z/i){
				$raid_single{'Physical_Disk_Number'} = $1;
				if ($raid_single{'Physical_Disk_Number'} > 0) {
					my @pd_array = ();
					my %pd_single = (
						'pd_id'			=> 'X',	# init
						'pd_type'		=> '',
						'position'		=> '',
						'raw_size'		=> '',
						'coerced_size'		=> '',
						'media_type'		=> '',
						'media_error'		=> '',
						'other_error'		=> '',
						'predictive_failure'	=> '',
						'firmware_state'	=> '',
						'inquiry_data'		=> '',
						'temperature'		=> '',
						'write_cache'		=> '',
					);
					my $pd_finish_flag = 0;
					open my $fh4, "$megacli -PDList -a$i -NoLog 2>&- | ";
					if($fh4){
						while(<$fh4>){
							chomp; s/(\A\s+|\s+\Z)//g;
							# if blank-line, check if single physical disk finished.
							if(/\A\s*\Z/i){	
								if($pd_single{'pd_id'} ne 'X' && $pd_finish_flag == 0){
									$pd_finish_flag = 1;
									my %tmp_pd_single = %pd_single;
									push @pd_array, \%tmp_pd_single;
								}else{
									$pd_finish_flag = 0;
									$pd_single{'pd_id'} = 'X';
								}
								next;
							}
							if(/\A\s*Device Id\s*:\s*(\d+)\s*\Z/i){
								$pd_single{'pd_id'} = $1;
								next;
							}	
							if(/\A\s*PD Type\s*:\s*(.+)\s*\Z/i){
								$pd_single{'pd_type'} = $1;
								next;
							}	
							if(/\A\s*Drive\'s postion\s*:\s*(.+)\s*\Z/i){
								$pd_single{'position'} = $1;
								next;
							}	
                                                        if(/\A\s*Raw Size\s*:\s*([\d.]+\s+(\w)+)\s*/i){
                                                                $pd_single{'raw_size'} = $1;
                                                                next;
                                                        }
                                                        if(/\A\s*Coerced Size\s*:\s*([\d.]+\s+(\w)+)\s*/i){
                                                                $pd_single{'coerced_size'} = $1;
                                                                next;
                                                        }
							if(/\A\s*Media Type\s*:\s*(.+)\s*\Z/i){
								$pd_single{'media_type'} = $1;
								next;
							}	
							if(/\A\s*Media Error Count\s*:\s*(.+)\s*\Z/i){
								$pd_single{'media_error'} = $1;
								next;
							}	
							if(/\A\s*Other Error Count\s*:\s*(.+)\s*\Z/i){
								$pd_single{'other_error'} = $1;
								next;
							}	
							if(/\A\s*Predictive Failure Count\s*:\s*(.+)\s*\Z/i){
								$pd_single{'predictive_failure'} = $1;
								next;
							}	
							if(/\A\s*Firmware state\s*:\s*(.+)\s*\Z/i){
								$pd_single{'firmware_state'} = $1;
								next;
							}	
							if(/\A\s*Inquiry Data\s*:\s*(.+?)\s*\Z/i){
								$pd_single{'inquiry_data'} = $1;
								next;
							}	
							if(/\A\s*Drive Temperature\s*:\s*(.+)\s*\Z/i){
								$pd_single{'temperature'} = $1;
								next;
							}	
							if(/\A\s*Drive\'s write cache\s*:\s*(.+)\s*\Z/i){
								$pd_single{'write_cache'} = $1;
								next;
							}	
						}
					}
					$raid_single{'Physical_Disk_Info'} = \@pd_array;
				}
				next;
			}
			if(/\A\s*Critical Disks\s*:\s*(\d+)\s*\Z/i){
				$raid_single{'Physical_Disks_Critical'} = $1;
				next;
			}
			if(/\A\s*Failed Disks\s*:\s*(\d+)\s*\Z/i){
				$raid_single{'Physical_Disks_Failed'} = $1;
				next;
			}
			if(/\A\s*Memory Correctable Errors\s*:\s*(\d+)\s*\Z/i){
				$raid_single{'Memory_Correctable_Errors'} = $1;
				next;
			}
			if(/\A\s*Memory Uncorrectable Errors\s*:\s*(\d+)\s*\Z/i){
				$raid_single{'Memory_Uncorrectable_Errors'} = $1;
				next;
			}
			if(/\A\s*Strip Size\s*:\s*(.+)\s*\Z/i){
				$raid_single{'Default_Strip_Size'} = $1;
				next;
			}
			if(/\A\s*Write Policy\s*:\s*(.+)\s*\Z/i){
				$raid_single{'Default_Write_Policy'} = $1;
				next;
			}
			if(/\A\s*Read Policy\s*:\s*(.+)\s*\Z/i){
				$raid_single{'Default_Read_Policy'} = $1;
				next;
			}
			if(/\A\s*Cache When BBU Bad\s*:\s*(.+)\s*\Z/i){
				$raid_single{'Default_Cache_When_BBU_Bad'} = $1;
				next;
			}
		}
  	}
	$raid_single{'RAID_Temp_Sensor'} = \%raid_temp_sensor;
  	push @raid_info, \%raid_single;
  }
}
### @raid_info



# PREPARE LAST RESULT HASH
my %result = (
	'product_info'		=> \%product_info,
	'mem_info'		=> \%mem_info,
	'cpu_info'		=> \%cpu_info,
	'input_dev'		=> \@input_dev,
	'os_info'		=> \%os_info,
	'sys_clock'		=> \%sys_clock,
	'sys_lang'		=> \%sys_lang,
	'selinux'		=> \%selinux,
	'sysuser'		=> \@sysuser,
	'runlevel'		=> $runlevel,
	'startups'		=> \@startups,
	'dns'			=> \@dns,
	'route'			=> \@route,
	'arp'			=> \@arp,
	'mount'			=> \@mount,
	'inet_name'		=> \@inet_name,
	'raid_info'		=> \@raid_info,
);
### %result

$result = JSON->new->utf8(1)->ascii(1)->encode(\%result);
print "{ok}:{str}:{$filename|$filename|$result}";
exit $state_ok;
