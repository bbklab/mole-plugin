#!/usr/bin/env perl
use strict;
use warnings;
use utf8;
use Locale::Messages qw (textdomain bindtextdomain gettext nl_putenv);
binmode(STDIN, ":encoding(utf8)");
binmode(STDOUT, ":encoding(utf8)");
binmode(STDERR, ":encoding(utf8)");
binmode STDOUT, ':raw';

# return codes
our ($state_ok,$state_warn,$state_crit,$state_unkn,$state_noop) = (0,1,2,3,4);

# return stuff
our ($rc, $result) = (0,'');

our $eminfo = '/usr/local/eminfo/eminfo';
our $filename = (split /\//, __FILE__)[-1];
our $tracefile = "/var/tmp/$filename.trace";

# check eminfo
unless (-f $eminfo && -x $eminfo) {
  printf "{unknown}:{str}:{$eminfo not prepared.}";
  exit $state_unkn;
}

# read eminfo locale_def
our $localdir = '/usr/local/eminfo/share/locale/';
open my $fh, "$eminfo printdef LOCALE_DIR 2>&- |";
if($fh){
  while(<$fh>){
        chomp; $localdir = $_;
        last;
  }
}

# read plugin locale setting
our $locale = 'zh_CN.UTF-8';
open $fh, "$eminfo view $filename locale 2>&- |";
if($fh){
  while(<$fh>){
        chomp; $locale = $_;
        last;
  }
  if(!defined $locale || $locale eq ''){
        open my $fh1, "$eminfo view default locale 2>&- |";
        if($fh1){
                while(<$fh1>){
                        chomp; $locale = $_;
                        last;
                }
        }
  }
}
if(!defined $locale || $locale eq ''){
        $locale = 'zh_CN.UTF-8';
}elsif($locale eq 'zh_CN' || $locale eq 'zh_CN.UTF-8' || $locale eq 'zh'){
        $locale = 'zh_CN.UTF-8';
}elsif($locale eq 'en_US' || $locale eq 'en_US.UTF-8' || $locale eq 'en'){
        $locale = 'en_US.UTF-8';
}else{
        $locale = 'zh_CN.UTF-8';
}
nl_putenv("LANGUAGE=$locale");

# set textdomain; bindtextdomain
sub _ ($) { &gettext; }
textdomain "$filename";
bindtextdomain "$filename", "$localdir";

# read plugin config here
our $messagefile = '/var/log/messages';
open $fh, "$eminfo view $filename messagefile 2>&- |";
if ($fh) {
  while(<$fh>){
  	chomp; $messagefile = $_;
	last;
  }
}

# define dev, inode, position for {messagefile}
our ($dev, $inode, $position) = ();

# define savepos
sub savepos {
  my ($messagefile, $position, $tracefile) = @_;
  if (open FH, ">$tracefile") {
  	($dev, $inode) = (stat $messagefile)[0,1];
	print FH "$dev $inode $position";
	close FH;
  } else {
	return undef;
  }
}

# define loadpos
sub loadpos {
  my $tracefile = shift;
  if (open FH, "<$tracefile") {
	while (<FH>) {
  		($dev, $inode, $position) = (split /\s+/)[0,1,2];
		last;
	}
	close FH;
  }
}

# Main body begin
unless (-f $messagefile) {
  printf _"{noop}:{str}:{ message file [%s] not exists. }",$messagefile;
  exit $state_noop;
}
# 1. load position from tracefile
loadpos ($tracefile);
unless ($dev && $inode && $position) {  # maybe first running
  savepos ($messagefile,0,$tracefile);	# save position again
  loadpos ($tracefile);			# load position again
}
# 2. read file dev,inode, checking rotated or not ?
my ($nowdev, $nowinode) = (stat $messagefile)[0,1];
if ($dev ne $nowdev || $inode ne $nowinode) {	# maybe messagefile logrotated
  savepos ($messagefile,0,$tracefile);		# save position again
  loadpos ($tracefile);				# load position again
}
# 3. open message file and goto last position directly
unless (open FH, "<$messagefile") {
  printf _"{noop}:{str}:{ open message file [%s] failed. }",$messagefile;
  exit $state_noop;
}
seek (FH,$position,0);		# directly goto last position
# 4. scan message file record
my @record = ();
while (<FH>) {
  chomp;
  if (m/Out of Memory/i || m/oom-killer/i) {
	push @record,  "<font color=red>$_</font> ###";
  }
}
# 5. read nower position and save again.
my $newpos = tell(FH);
savepos ($messagefile, $newpos, $tracefile);
close FH;
# 6. prepare last output
unless (@record) {
  printf _"{noop}:{str}:{no oom event captured}";
  exit $state_noop;
} else {
  while (@record) {
  	$result .= shift @record;
  }
  $result = sprintf(_"oom event | captured oom event | ") . $result;
  printf _"{crit}:{str}:{%s}",$result;
  exit $state_crit;
}
